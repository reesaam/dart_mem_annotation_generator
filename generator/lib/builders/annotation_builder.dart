import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:analyzer/dart/element/visitor.dart';
import 'package:build/src/builder/build_step.dart';
import 'package:dart_mem_annotation/annotation.dart';
import 'package:dart_mem_annotation_generator/components/log.dart';
import 'package:dart_mem_annotation_generator/extensions/constant_reader.dart';
import 'package:dart_mem_annotation_generator/extensions/dart_type.dart';
import 'package:dart_mem_annotation_generator/extensions/generator_data.dart';
import 'package:dart_mem_annotation_generator/models/generator_data.dart';
import 'package:source_gen/source_gen.dart';

import '../components/add_class.dart';
import '../components/add_mapper.dart';
import '../functions/add_code.dart';
import '../models/variable.dart';
import '../resources/enums.dart';

/// This class will find the Annotation, Extract Data then Fill it in the Model to pass to the main generator class to generate the Code
///
/// The DataModel includes the source element itself and extracted useful data that we know will use them a lot
/// so, those useful data seperated and assigned a specific field for them
/// we would not process the demanded data everytime
///
/// Logs will notify that an annotation has founded, then it will show details about that

class AnnotationBuilder extends GeneratorForAnnotation<Mem> {
  @override
  FutureOr<String> generateForAnnotatedElement(Element element, ConstantReader annotation, BuildStep buildStep) async {
    GeneratorLog.info(title: 'Annotation Found', data: annotation.getName);
    GeneratorLog.info(title: 'Code Generation for Annotation Started');

    String code = '';

    GeneratorLog.info(title: 'Main Code Generation Started...');
    String className = element.name ?? 'UnnamedClass';
    List<Variable> variablesList = List<Variable>.empty(growable: true);
    ElementVisitor visitor = ElementVisitor();
    element.visitChildren(visitor);
    List<Element> fields = element.children.where((child) => child.kind == ElementKind.FIELD).toList();
    List<Element> constructors = element.children.where((child) => child.kind == ElementKind.CONSTRUCTOR).toList();

    // code += AddCode.addCommentLine('fieldElements:  ${visitor.fieldElements}');
    // code += AddCode.addCommentLine('propertyAccessorElement:  ${visitor.propertyAccessorElement}');

    GeneratorLog.info(title: 'Generating Variables and Checking DartTypes...');
    for (var item in fields) {
      DartType? selectedVisitorField = visitor.fieldElements[item.name];
      // code += selectedVisitorField == null ? '' : Prints.dartTypeInfo(selectedVisitorField);

      Variable variable = Variable(
        name: item.name ?? 'UnnamedVariable',
        type: selectedVisitorField,
        typeString: selectedVisitorField?.toString(),
        isCoreType: selectedVisitorField?.isDartCoreList == true ? selectedVisitorField?.isCoreTypeFromList : selectedVisitorField?.isCoreType,
        isFinal: item.declaration.toString().contains('final'),
        hasRequired: constructors.first.children.isEmpty ? null : constructors.first.children.firstWhere((e) => e.name == item.name).declaration.toString().contains('required '),
        isNullable: item.declaration?.toString().split(' ').first.contains('?'),
        isEnum: selectedVisitorField?.isEnum,
        isList: selectedVisitorField?.isDartCoreList,
      );
      variablesList.add(variable);
    }

    GeneratorLog.info(title: 'Commenting Started');
    code += AddCode.addCommentLine('  This File is Generated by Mem Generator');
    code += AddCode.addCommentLine('  [$className] Annotated with [Mem] with [${annotation.getName}] mode');
    code += AddCode.addCommentLine('  Including:');
    code += AddCode.addCommentLine('    Model Class, Entity Class and Mapper Class,');
    code += AddCode.addCommentLine('    Model Classes includes [toJson] and [fromJson] functions, and Entity Classes are not!');
    code += AddCode.addCommentLine('    Mappers will convert every filed in the class including [SubClasses], they should be annotated as well.');
    code += AddCode.addCommentLine(
        '    [Mem] Annotation will generate all these fields for all Classes, so all subclasses should decorated with annotation to generate model, entity and mapper to use them here');
    code += AddCode.addCommentLine('    [Enums] also supported and they will be detected and count into account for mappers and also json conversion');
    annotation.getFreezed == true ? code += AddCode.addCommentLine('    Classes are decorated with [Freezed], other functions will generate with [Freezed]') : null;
    code += AddCode.addSpace();
    code += AddCode.addCommentLine('  Details:');
    code += AddCode.addCommentLine('    Class: ${annotation.getAs ?? className}');
    code += AddCode.addCommentLine('    Constructors Count: ${constructors.length}');
    code += AddCode.addCommentLine('    Variables Count: ${variablesList.length}');
    code += AddCode.addSpace();

    GeneratorLog.info(title: 'Generating Classes (Model and Entity) for', data: className);
    code += AddCode.addCommentLine('  ==> Model Class:');
    GeneratorData generatorData = GeneratorData(
      className: annotation.getAs ?? className,
      variablesList: variablesList,
      isFreezed: annotation.getFreezed,
      extended: annotation.getIsExtended,
    );

    code += AddClass().generate(generatorData.copyWith(annotationType: AnnotationTypes.model));
    code += AddCode.addCommentLine('  ==> Entity Class:');
    code += AddClass().generate(generatorData.copyWith(annotationType: AnnotationTypes.entity));
    GeneratorLog.info(title: 'Generating Mapper Class for', data: className);
    code += AddCode.addCommentLine('  ==> Mapper Classes:');
    code += AddMapper().generate(generatorData);

    GeneratorLog.info(title: 'Completing Code Generation and Preparing Files...');
    return code;
  }
}

class ElementVisitor extends SimpleElementVisitor {
  Map<String, DartType> fieldElements = {};
  Map<String, PropertyAccessorElement> propertyAccessorElement = {};

  @override
  visitFieldElement(FieldElement element) => fieldElements[element.name] = element.type.extensionTypeErasure;
  @override
  visitPropertyAccessorElement(PropertyAccessorElement element) => propertyAccessorElement[element.name] = element;
}
