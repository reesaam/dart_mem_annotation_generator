import 'dart:async';
import 'package:build/src/builder/build_step.dart';
import 'package:source_gen/source_gen.dart';
import '../components/descriptions_generator.dart';
import '../components/log.dart';
import '../models/extracted_info_model.dart';
import '../resources/constants.dart';
import '../resources/enums.dart';
import '../extensions/string.dart';
import '../resources/strings.dart';

class CodeGenerator extends Generator {
  /// List Variables to keep the data and then we will use them when generating the code
  /// This way everything, especially generating the code do so much faster and more efficient
  static Set<String> importsList = Set<String>.new();
  static Set<ExtractedInfoModel> variables = Set<ExtractedInfoModel>.new();

  @override
  FutureOr<String?> generate(LibraryReader library, BuildStep buildStep) async {
    /// String Variables
    /// These variables will keep strings of generated code separately
    /// [statisticsCodeBody] the package will generate some statistics about received code which will put at the top of generated code
    /// [importsCodeBody] this is the [import] section, all the demanded imports will gather, save and finally generate here
    /// [pagesCodeBody] we have a section for store and generate pages which we should represent to [GetX] separately
    /// [initialPageString] in the pages section we should hold a initial page to represent to [GetX]
    /// [unknownPageString] therefore, we have a unknown route to represent
    /// [controllersCodeBody] controllers are controllers of the pages
    /// [componentsCodeBody] components are obvious
    /// [repositoriesCodeBody] repositories could include all the repositories in the app, everything that you can name as repository
    /// all these 3 fields are known as Controllers in the [GetX] but they can have separate meanings or concepts
    /// so we will separate them as meanings, but they will add to the dependencies part which is the next
    /// and they have a similar behavior as [GetX] perspective
    /// [dependenciesCodeBody] this part provides all 3 dependency functions and merge them into a function to represent
    /// [bindingsCodeBody]
    ///
    /// then we can have them in different parts, at first step it will so much easier to debug and find every problem
    /// which occurred and generated by every part of the code
    /// at the end, all of them will merge in a unified string for pass to the generating the file
    /// the only variable that could assume different is [mainCodeBody] which will keep the final merged code
    
    String statisticsCodeBody = Strings.empty;
    String importsCodeBody = Strings.empty;
    String variablesCodeBody = Strings.empty;
    String mainCodeBody = Strings.empty;

    /// generator could generate everywhere and with every file
    /// it will be restricted this way to generate specific file and save resources
    GeneratorLog(title: 'Code Generation Started...');

    /// Imports
    for (var import in importsList) {
      importsCodeBody = importsCodeBody.addImport(import);
    }

    ///Statistics
    statisticsCodeBody = statisticsCodeBody.addCommentLine('Generated Library Statistics:');
    statisticsCodeBody = statisticsCodeBody.addCommentLine('  Imports Count: ${importsList.length}');

    /// CodeBody Generation
    mainCodeBody = mainCodeBody.addLine('library;').addSpace();
    mainCodeBody = mainCodeBody.addCommentLine(DescriptionGenerator().generate(all: true)).addSpace();
    mainCodeBody = mainCodeBody.addLine(importsCodeBody).addSpace();
    mainCodeBody = mainCodeBody.addLine(statisticsCodeBody).addSpace();

    GeneratorLog(title: 'Code Generation Finished...');

    bool canPublish = mainCodeBody.isNotEmpty;
    return canPublish ? mainCodeBody : null;
  }

  /// This function is responsible to get the specific element that we need to process
  /// and pull it from everywhere in the codebase to here to add and keep in the lists
  addElement(ExtractedInfoModel element) {
    importsList.add(element.source.correctImport);
  }

  /// These functions are helping generating the Strings and being unified
  /// these are mostly general concepts and may use several places, so we can change them here to have the change everywhere easily
  String _pageDependencyFormat(ExtractedInfoModel element) => 'GetPage(name: \'/${element.as ?? element.name}\', page: ${element.name}.new)';
  String _controllerDependencyFormat(ExtractedInfoModel element) => 'Get.lazyPut<${element.as ?? element.name}>(() => ${element.name}());';
}
